########## 1. SINGLETON #############
> Singleton purpose is TO CONTROL OBJECT CREATION, limiting the no. of obj to one only
> Singletons often control access to resources such as database connections or sockets using 1 connection only
- It is used for logging, drivers objects, caching and thread pool.

Ex - window managers, print spoolers, filesystems 

Singleton design consist of a 
1. PRIVATE CONSTRUCTOR 
- to prevents any other class from instantiating

2. PUBLIC STATIC SYNCHRONIZED 'INSTANCE' METHOD like getInstance() 
- to return Singleton class instance and by using synchronized we force every thread to wait for its turn before it can enter the method

3. OTHER PROTECTED STATIC METHOD for processing

class diagram
|---------------------|
|  CLASS NAME         |
|---------------------|
|static uniqueinstance|
|---------------------|
|static getInstance() |
|---------------------|

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##What is Singleton class? Have you used Singleton before?

> Singleton is a class which has ONLY ONE INSTANCE in whole application
> provides a getInstance() method to access the singleton instance.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##Which classes are candidates of singleton? Which kind of class do you make singleton?

> When a class is available to whole application and only one instance is required then it can be singleton class
> Ex - Runtime class - here Java runtime prgmg  	

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Example of Singleton in Java?

1 Java.lang.Runtime with getRuntime() 
- used to get free memory and total memory in Java.

2 Java.awt.Toolkit with getDefaultToolkit()
3 Java.awt.Desktop with  getDesktop()
4. java.lang.System.getSecurityManager()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Is it better to make whole getInstance() method synchronized or just critical section is enough? Which one you will prefer?

> Since synchroniztion is only needed during initialization of singleton instance, to prevent creating another instance,  
- Its better to only synchronize critical section and not whole method.

> Singleton pattern is also closely related to factory design pattern
=====================================
##How to create thread-safe singleton objects in Java?
##What is double checked locking in Singleton?

> to make the getInstance method synchronized 

public class Singleton {
 private static Singleton instance = null;
 private Singleton() {}
 
 public static synchronized Singleton getInstance() {
   if (instance == null) {
     instance = new Singleton();
   }
   return instance;
 }
} 
> Above code works fine and provides thread-safety but IT REDUCES PERFORMANCE because of cost associated with the synchronized method. 

> this design is not optimal as every invocation of getInstance() is synchronized while the requirement is only for the first call. 

> A slightly BETTER SOLUTION is to synchronize only the new instance creation instead of the entire method. 
- This solution requires an additional check for null inside the synchronized block and is termed as DOUBLE CHECK LOCKING OPTIMIZATION.
 
public class Singleton {
  private static Singleton instance = null;
  private Singleton() {
  }
  public static Singleton getInstance() {
    if (instance == null) {
      synchronized(Singleton.class){//one time cost
        if (instance == null) 
          instance = new Singleton();
      }
    }
    return instance;
  }
}
> It will be best to use the volatile instance variable in Singleton class
- it will ensure the object is not partially initialized and it is the one.
as private static volatile Singleton instance =null;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Why you need Double checked Locking of Singleton Class?

> It improve the performance of code and to minimize cost of synchronization in case of multi-threading env.
- Here instance creation is only 1 time cost and only 1 thread can obtain lock on the class and create instance
- another thread either wait or will get the instantiated obj.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##### PREVENT FROM CLONING ######

##	How do you prevent for creating another instance of Singleton using clone() method?
1. By not implementing Clonable interface 
2. If the class is implementing then throw exception from clone() as 
  @Override
  protected Object clone() throws CloneNotSupportedException {
    throw new CloneNotSupportedException();
  }
 
3. If you dont want to throw exception we can also return the same instance from clone method. 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#### PREVENT FROM REFLECTION ####

##How do you prevent for creating another instance of Singleton using reflection?
> This can be avoided by throwing Exception from constructor as Singleton already initialized

private Singleton() {
    if( Singleton.singleton != null ) {
        throw new InstantiationError( "Creating of this object is not allowed." );
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### PREVENT FROM SERIALIZATION ###

## How do you prevent for creating another instance of Singleton during serialization?

> can prevent this by using readResolve() in Singleton class which implement Serializable[i], 
- since during serialization readObject() is used to create instance and it return new instance every time but by using readResolve 
> we can replace it with original Singleton instance.

Example :
class Singleton implements Serializable 
{
  // public instance initialized when loading the class
  public static Singleton instance = new Singleton();
   
  private Singleton(){
      // private constructor
  }
   
  // implement readResolve method
  protected Object readResolve(){
      return instance;
  }
}
=======================================
## DIFFERENT APPROACHES OF SINGLETON PATTERN

1. Eager initialization
2. Static block initialization
3. Lazy Initialization
4. Thread Safe Singleton
5. Bill Pugh Singleton Implementation
6. Using Reflection to destroy Singleton Pattern
7. Enum Singleton
Serialization and Singleton

https://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples
=======================================
##### INNER STATIC CLASS APPROACH #####

## How to create thread-safe singleton objects in Java without using 'synchronized'?

> Thread-safe singleton class can be created using INNER STATIC CLASS APPROACH.
 
public class Singleton {   
    private Singleton() {  }
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }
    public static Singleton getInstance(){
        return SingletonHolder.INSTANCE;
    }
}
 
> Here the private static inner class contains the instance of the Singleton class. 
> When the Singleton class is loaded, SingletonHolder class is NOT LOADED INTO MEMORY. 
> SingletonHolder class gets loaded on first invocation of the getInstance method and creates the Singleton class instance. 
> Java Language Specification guarantees the CLASS INITIALIZATION PROCESS TO BE SERIAL (NON-CONCURRENT) SO NO SYNCH. is required in the getInstance method. 
- This solution guarantees single instance and achieves better performance than using synchronized keyword. 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##What is lazy and early loading of Singleton and how will you implement it?
##Difference between lazy initialization and early initialization ?

> LAZY INITIALIZATION : We create the object of the class only when it is about to use in the program code .
> We are calling it lazy because we wait till the last moment to have an object.

> EARLY INITIALIZATION :  In this we create the object when the class is getting loaded into the JVM . 
> it is helpful if our application always create and use the Singleton class .
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## When doesn't Singleton remain Singleton in Java?

## What are the drawbacks of Singleton?

> major drawbacks of using singleton design pattern are:
1. Singleton causes code to be tightly coupled. 
- The singleton object is exposed globally and is available to a whole application. Thus, classes using this object become tightly coupled; 
- ANY CHANGE IN THE GLOBAL OBJECT WILL IMPACT ALL OTHER CLASSES using it.

2. They hide dependencies instead of exposing them.
3. SINGLETON PATTERN DOES NOT SUPPORT INHERITANCE.
4. Singleton principle can be violated by techniques such as cloning. 
- If an application is running on multiple JVMâ€™s, then, in this case, Singleton might be broken