## What is CONCURRENCY?

> Concurrency is the ability of a program to EXECUTE SEVERAL COMPUTATIONS SIMULTANEOUSLY(i.e at same time). 
> This can be achieved by distributing the computations over the available CPU cores of a machine or even over different machines within the same network.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is problem of using Concurrency?

> There are TWO BASIC PROBLEMS, visibility and access problems.

1. VISIBILITY PROBLEM
> it occurs if thread A reads shared data which is later changed by thread B and thread A is unaware of this change.

2. ACCESS PROBLEM 
> it can occur if several thread access and change the same shared data at the same time.

> Job Ordering is Nondeterministic

Visibility and access problem can lead to
> LIVENESS FAILURE: 
- The program does not react anymore due to problems in the concurrent access of data, e.g. deadlocks.

> SAFETY FAILURE: 
- The program creates incorrect data.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is difference between Concurrency and Parallelism?

> Concurrency means MULTIPLE TASKS WHICH START, RUN, AND COMPLETE IN OVERLAPPING TIME PERIODS, IN NO SPECIFIC ORDER. 
- Concurrency is about dealing with lot of things at once.
- It means that multiple task are started at the same time and each task make progress.
- It doesn't necessarily mean they'll ever both be running at the same instant
- To deal with concurrency - use Locks/Synchronized, Atomic Classes, Concurrent DS, CompletableFuture, CountDownLatch/Phaser/CyclicBarrier/Semaphore etc 

> Parallelism is when multiple tasks OR SEVERAL PART OF A UNIQUE TASK LITERALLY RUN AT THE SAME TIME, e.g. on a multi-core processor.
- Parallelism is about doing lots of thing at once.
> It means that an app splits its tasks up into smaller subtasks which can be processed in parallel (sequencially).
- It require special resource for its execution like multicore processor.

> In single core CPU, we may get concurrency but NOT parallelism
=====================================
######### CALLABLE & FUTURE #########

## What is java.util.concurrent.Callable[i]?

> it is an interface like runnable 
> it represent a TASK THAT RETURN SOME RESULT OR MAY THROW SOME EXCEPTION i.e. checked Exception.
- it USE GENERIC TO DEFINE RETURN TYPE of Object. 
> Executors class provide useful methods to execute Callable in a thread pool. 
> Callable tasks return java.util.concurrent.Future object. 

@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is difference between Callable[i] and Runnable[i]?

> Runnable has run() that accepts no args and returns no value
- nor it can throw any checked exception. 
- To overcome these limitations Callable[i] introduce in JDK1.5

> Callable[i] have call() that ret. an Obj 
- we cannot pass callable into Thread for execution like 
Thread t = new Thread(new MyCallableTask()); //don;t compile

- For this we have ExecutorService to execute Callable obj.
- ExecutorService return Future obj which represent life-cycle of task. 
=====================================
############# FUTURE[i] #############
> Since Java5

## What is Future interface?

> it REPRESENTS LIFE CYCLE OF A TASK(i.e result of task)
> It provide methods to obtain the result generated by a Callable object and to manage its state.

> it retrieve the result, and cancel the task

#### METHODS #### 
1. boolean cancel(boolean mayInterruptIfRunning);

- use to cancel execution of this task. 
- This attempt will fail if the task has already completed/cancelled/ could not be cancelled for some other reason.
- If the task has already started, then the "mayInterruptIfRunning" parameter determines whether to interrupt or not.
-----------------------------
2. boolean isCancelled() : 

- Returns true if this task was cancelled before it completed normally
-----------------------------
3. boolean isDone() 

- ret true if task completed. 
- Completion may be due to normal termination, an exception, or cancellation in all case return true.
-----------------------------
4. V get() throws InterruptedException, ExecutionException;

- waits for the completion of the computation. 
- If the returning value is null, the task has finished correctly
-----------------------------
5. V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException;

- if the result of the task isn’t available, waits for the specified time. 
- If the specified period of time passes and the result isn’t yet available, the method returns a null value.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What are the limitation of Futures ?

1. It CANNOT BE MANUALLY COMPLETED with partial results.

2. We cannot perform further action on a Future’s result without blocking
- it DOES NOT NOTIFY OF ITS COMPLETION. 
- It provides a get() which blocks until the result is available.
- it don’t have the ability to attach a callback function to the Future and have it get called automatically when the Future’s result is available.

3. MULTIPLE FUTURES CANNOT BE CHAINED TOGETHER
4. we can not combine multiple Futures together.
5. there is no exception handling. 

- To address this shortcomings, Java 8 introduced CompletableFuture.
=======================================
## What is FutureTask[c]?

class FutureTask<V> implements RunnableFuture<V>

> FutureTask is the base impl class of Future[i] 
> use when we want to OVERRIDE SOME METHODS OF Future[i] and want to keep most of the base impl. 

1. protected boolean runAndReset()
2. protected void set(Obj) 
3. protected void done(){} 
- Subclasses may override this method to invoke completion callbacks or perform bookkeeping
=======================================
## What is RunnableFuture[i]?

> it is interface which extends Runnable and Future
> it have 1 method run():void 
- bcz we need not to impl. run() in our subclass. 
- Basic impl will work define in FutureTask[c]
- while in Runnable subclass we need to impl run()  
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
=======================================
######## CompletableFuture[c] #########
> Since Java8
> package java.util.concurrent

class CompletableFuture<T> implements Future<T>, CompletionStage<T> {...}

## What is CompletableFuture[c]?

> it is used for asynchronous programming in Java.
 
> Asynchronous programming is a means of writing non-blocking code by RUNNING A TASK ON A SEPARATE THREAD than the main app thread and 
- it notify the main thread about its progress, completion or failure
- In this way, the main thread does not block or wait for the completion of the task.

- it implements Future and CompletionStage

- it executes these tasks in a thread obtained from the global ForkJoinPool.commonPool().

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
########## METHODS ############

1. To create CompletableFuture using no-args constructor
CompletableFuture<String> completableFuture = new CompletableFuture<String>();

2. get()
- CompletableFuture.get() is blocking. 
- It waits until the Future is completed and returns the result after its completion.

2. complete()

# static CompletableFuture<Void>  runAsync(Runnable runnable)
# static CompletableFuture<Void>  runAsync(Runnable runnable, Executor executor)
- for asynchronous computation
- it doesn't return anything, just run in background. It takes runnable obj

# static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)
# static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)
- Run a task asynchronously and return the result 
- It takes a Supplier<T> and returns CompletableFuture<T> on which we can apply other methods.


# thenApply()
- to process and transform the result of a CompletableFuture when it arrives. 
- It takes a Function<T,R> as an argument.
- It returns a new CompletableStage when this stage completes normally. 


# join(): 
- the method returns the result value when complete. 
- It also throws a CompletionException (unchecked exception) if completed exceptionally.

> There are 3 method to handle an exception:
# CompletableFuture <T> exceptionally(Function function);  
# CompletableFuture<U> hadle(BiFunction bifunction);  
# CompletableFuture<T> whenComplete(BiConsumer action);  
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is diff bet Future and CompletableFuture?

> CompletableFuture[c] is the extension of Future[i]

> Future doesn't provide chaining and combining of multiple futures but
- CompletableFuture provides chaining and combining of multiple futures
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is CompletionStage[i]?

> It performs an action and returns a value when another completion stage completes.

> A model for a task that may trigger other tasks.
- Hence, it is an element of a chain.

> When more than one thread attempt to complete - complete exceptionally OR cancel a CompletableFuture, only one of them succeeds.

> CompletionStage offers methods, that let you attach callbacks that will be executed on completion.
=======================================
By default, Future task is run asynchronously, so will be executed in a different Thread from the one which added it by calling the execute method. For example ” Thread1? called execute method , Futuretask will be executed in “Thread2"

> Callable by default will be executed on same Thread , unless you are using custom executor that starts a new thread.


=======================================	
	
https://netjs.blogspot.com/2016/05/java-concurrency-interview-questions.html	