## What is CONCURRENCY?

> Concurrency is the ability of a program to EXECUTE SEVERAL COMPUTATIONS SIMULTANEOUSLY(i.e at same time). 
> This can be achieved by distributing the computations over the available CPU cores of a machine or even over different machines within the same network.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is problem of using Concurrency?

> There are TWO BASIC PROBLEMS, visibility and access problems.

1. VISIBILITY PROBLEM
> it occurs if thread A reads shared data which is later changed by thread B and thread A is unaware of this change.

2. ACCESS PROBLEM 
> it can occur if several thread access and change the same shared data at the same time.

> Job Ordering is Nondeterministic

Visibility and access problem can lead to
> LIVENESS FAILURE: 
- The program does not react anymore due to problems in the concurrent access of data, e.g. deadlocks.

> SAFETY FAILURE: 
- The program creates incorrect data.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is difference between Concurrency and Parallelism?

> Concurrency is about dealing with lot of things at once.
- It means that multiple task are started at the same time and each task make progress.
- It doesn't necessarily mean they'll ever both be running at the same instant
- To deal with concurrency - use Locks/Synchronized, Atomic Classes, Concurrent DS, CompletableFuture, CountDownLatch/Phaser/CyclicBarrier/Semaphore etc 

> Parallelism is about doing lots of thing at once.
> It means that an app splits its tasks up into smaller subtasks which can be processed in parallel (sequencially).
- It require special resource for its execution like multicore processor.
=====================================
######### CALLABLE & FUTURE #########
##What is java.util.concurrent.Callable[i]?

> it is an interface like runnable 
> it represent a TASK THAT RETURN SOME RESULT OR MAY THROW SOME EXCEPTION i.e. checked Exception.
- it USE GENERIC TO DEFINE RETURN TYPE of Object. 
> Executors class provide useful methods to execute Callable in a thread pool. 
> Callable tasks return java.util.concurrent.Future object. 

@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is difference between Callable[i] and Runnable[i]?

> Runnable has run() that accepts no args and returns no value
- nor it can throw any checked exception. 
- To overcome these limitations Callable[i] introduce in JDK1.5

> Callable[i] have call() that ret. an Obj 
- we cannot pass callable into Thread for execution like 
Callable task = new CallableEmp(); Thread t = new Thread(task); //don;t compile

- For this we have ExecutorService to execute Callable obj.
- ExecutorService return Future obj which represent life-cycle of task. 
=====================================
############# FUTURE[i] #############

##What is Future interface?

> it REPRESENTS LIFE CYCLE OF A TASK(i.e result of task)
> It provide methods to obtain the result generated by a Callable object and to manage its state.

> it retrieve the result, and cancel the task

#### METHODS #### 
1. boolean cancel(boolean mayInterruptIfRunning);
- use to cancel execution of this task. 
- This attempt will fail if the task has already completed/cancelled/ could not be cancelled for some other reason.
- If the task has already started, then the "mayInterruptIfRunning" parameter determines whether to interrupt or not.
-----------------------------
2. boolean isCancelled() : 
- Returns true if this task was cancelled before it completed normally
-----------------------------
3. boolean isDone() 
- ret true if task completed. 
- Completion may be due to normal termination, an exception, or cancellation in all case return true.
-----------------------------
4. V get() throws InterruptedException, ExecutionException;
- waits for the completion of the computation. 
- If the returning value is null, the task has finished correctly
-----------------------------
5. V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException;
=======================================
## What is FutureTask Class?
class FutureTask<V> implements RunnableFuture<V>

> FutureTask is the base impl class of Future[i] 
> use when we want to OVERRIDE SOME METHODS OF Future[i] and want to keep most of the base implementation. 

1. protected boolean runAndReset()
2. protected void set(Obj) 
3. protected void done(){} 
- Subclasses may override this method to invoke completion callbacks or perform bookkeeping
=======================================
##What is RunnableFuture[i]?
> it is interface which extends Runnable and Future
> it have 1 method run():void bcz we need not to impl. run() in our subclass. 
- Basic impl will work define in FutureTask[c]
- while in Runnable subclass we need to impl run()  
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CompletableFuture extends the functionality of the Future[i] for asynchronous calls. 
> It also implements the CompletionStage[i]. 
> CompletionStage offers methods, that let you attach callbacks that will be executed on completion.
=======================================
By default, Future task is run asynchronously, so will be executed in a different Thread from the one which added it by calling the execute method. For example ” Thread1? called execute method , Futuretask will be executed in “Thread2"

> callable by default will be executed on same Thread , unless you are using custom executor that starts a new thread.
=====================================
########### FORK / JOIN #############
> FORK/JOIN framework is an implementation of the ExecutorService interface that helps to take advantage of multiple processors.
> It is designed for work that can be broken into smaller pieces recursively. 
> It distributes tasks to worker threads in a thread pool
> fork/join framework is distinct because it uses a WORK-STEALING ALGORITHM.
> Worker threads that run out of things to do can steal tasks from other threads that are still busy.

> core classes supporting the Fork-Join mechanism are ForkJoinPool and ForkJoinTask
> It is introduce in java7

## FORK AND JOIN PRINCIPLE ##
fork and join principle consists of two steps i.e fork and join steps which are performed recursively.

FORK - A task that uses the fork and join principle can fork (split) itself into smaller subtasks which can be executed concurrently.
JOIN - When a task has split itself up into subtasks, the task waits until the subtasks have finished executing.

############ ForkJoinPool ###########
- ForkJoinPool extends AbstractExecutorService

## What is ForkJoinPool?
> It is a special thread pool which is designed to work well with ForkJoinTask
> It is basically a specialized implementation of ExecutorService IMPLEMENTING THE WORK-STEALING ALGORITHM
> It maintains a number of threads, which number is typically based on the number of CPUs available

> we can submit two types of tasks. 
- RecursiveAction[c] - A task that does not return any result (an "action"), and 
- RecursiveTask[c] - a task which does return a result (a "task"). 

EXAMPLE:
int numberOfProcessors = Runtime.getRunTime().availableProcessors();//indicate level of parallelism
ForkJoinPool pool = new ForkJoinPool(numberOfProcessors);

- If no-argument pass then by default, it creates a pool of size that equals the number of available processors obtained.
- pool adjusts its size dynamically in an attempt to maintain enough active threads 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## How ForkJoinPool work?

> Each thread has a special kind of queue, Deques, where all its tasks are placed
- threads do not share a common queue, but each thread has its own queue 

> threads put aside a task which are blocked/waiting for someother task
In other words, if the current task cannot proceed (as it performs a join on a subtask), then it is placed on this queue until all of its dependencies are ready.

> tasks are added to the thread’s queue (using the fork operation) and each thread always processes the last task added to its queue (i.e LIFO maner)

> Any idle threads can take tasks from the other threads queues if available, that is, work-stealing
- A thread will always steal oldest tasks from some other thread’s queue

http://www.javacreed.com/java-fork-join-example/
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is difference between ForkJoinPool and other ExecutorService?

> main difference between the Fork/Join and the Executor frameworks is the work-stealing algorithm. 
> In Fork-Join, pool need NOT be EXPLICITLY SHUTDOWN upon program exit because all its THREADS ARE IN DAEMON MODE.

three different ways of submitting a task to the ForkJoinPool.

1) execute() method //Desired asynchronous execution; call its fork method to split the work between multiple threads.
2) invoke() method: //Await to obtain the result; call the invoke method on the pool.
3) submit() method: //Returns a Future object that you can use for checking status and obtaining the result on its completion.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#### ForkJoinTask ####
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#### Existing Implementations in JDK 
> use of fork/join framework.

> in Java SE 8, parallelSort() of java.util.Arrays class 
> Parallelism used in Stream.parallel()
========================================
## SHUTDOWN HOOK
> It can be USED TO PERFORM CLEANUP RESOURCE OR SAVE THE STATE when JVM shuts down normally or abruptly. 
> Performing clean resource means closing log file, sending some alerts or something else. 
> So if you want to execute some code before JVM shuts down, use shutdown hook.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##When does the JVM shut down?
> The JVM shuts down when:
	-user presses ctrl+c on the command prompt
	-System.exit(int) method is invoked
	-user logoff
	-user shutdown etc.
---------------------
> The addShutdownHook() method of Runtime class is used to register the thread with the Virtual Machine
public void addShutdownHook(Runnable r){}  

> Runtime class can be obtained by calling the static factory method getRuntime(). 
	Runtime r = Runtime.getRuntime();
	
=======================================
######### CountDownLatch[c] ###########
> Since Java5
##What is CountDownLatch class?
> It is a KIND OF SYNCHRONIZER which allows one Thread to wait for one or more Threads before starts processing. 
- it is used when threads hv to wait for some other threads that reached to some state then only waiting thread starts

> it provide synchr. counter that decrease till 0 then only it instance proceed other thread

> It is MAINLY USED IN SERVER SIDE CORE JAVA APPLICATION WHICH USES SERVICES ARCHITECTURE 
- where multiple services is provided by multiple threads and application can not start processing until all services have started successfully 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## How CountDownLatch works?
> defines one constructor : CountDownLatch(int count) 
- Here count : number of threads, for which latch should wait. 
- This value can be SET ONLY ONCE, and CountDownLatch provides NO OTHER MECHANISM TO RESET THIS COUNT

> first interaction with CountDownLatch is with main thread which is goind to wait for other threads. 
- This main thread must call, CountDownLatch.await() method immediately after starting other threads. 
- The execution will stop on await() method till the time, other threads complete their execution.

> Other N threads must have reference of latch object, because they will need to notify the CountDownLatch object that they have completed their task.
- This notification is done by method : CountDownLatch.countDown();

EXAMPLE:
public static void main(String args[]) {
    final CountDownLatch latch = new CountDownLatch(3);
    
	Thread cacheService = new Thread(new Service("CacheService", 1000, latch));
    Thread alertService = new Thread(new Service("AlertService", 1000, latch));
    Thread validationService = new Thread(new Service("ValidationService", 1000, latch));
    
    cacheService.start(); //separate thread will initialize CacheService
    alertService.start(); //another thread for AlertService initialization
    validationService.start();
    
    // application should not start processing any thread until all service is up
    //each thread once up and read will do a count down. 
    
    try{
         latch.await();  //main thread is waiting on CountDownLatch to finish
         System.out.println("All services are up, Application is starting now");
    }catch(InterruptedException ie){
        ie.printStackTrace();
    }      
}

class Service implements Runnable{
    private final String name;
    private final int timeToStart;
    private final CountDownLatch latch;
  
    public Service(String name, int timeToStart, CountDownLatch latch){
        this.name = name;
        this.timeToStart = timeToStart;
        this.latch = latch;
    }

    public void run() {
        try {
            Thread.sleep(timeToStart);
        } catch (InterruptedException ex) {
            Logger.getLogger(Service.class.getName()).log(Level.SEVERE, null, ex);
        }
        System.out.println( name + " is Up");
        latch.countDown(); //reduce count of CountDownLatch by 1
    } 
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is the difference between a CountDownLatch and a CyclicBarrier?
SIMILARITY
> Both classes maintain INTERNAL COUNTER that is decremented by different threads
>
DIFFERENCE
> CountDownLatch class doesnot reset its counter
- CyclicBarrier RESETS THE INTERNAL VALUE back to the initial value once the value reaches zero

=======================================
########### ATOMIC #############
## What is atomic operation? What are atomic classes in Java Concurrency API?
> an operation which is performed as a single unit of work without the possibility of interference from other operations.

> Java language specification guarantees that reading or writing a variable is an atomic operation(unless the variable is of type long or double ). 
- Operations variables of type long or double are only atomic if they declared with the volatile keyword.

> int++ is not an atomic operation. 
- So by the time 1 threads read value and increment by 1, other thread read old value leads to wrong result.

> it come under java.util.concurrent.atomic package
> it performed in a single unit of task 
- it perform to avoid data inconsistency.



> To solve this issue, we can use Synchronization 
- but Java 5 java.util.concurrent.atomic provides wrapper classes for int and long that achieve this atomically without usage of Synchronization. 
- count.incrementAndGet() is atomic operation and equal to count++;
=====================================
############### LOCKS ###############
## What is Lock interface in Java Concurrency API? What are it’s benefits over synchronization?

> it come under java.util.concurrent.locks package
> Lock[i] PROVIDE MORE EXTENSIVE LOCKING OPERATIONS than can be obtained using synchronized methods and statements. 
- allow more flexible structuring and support multiple associated Condition objs. 
> it facilitate more effective locking system

> The ADVANTAGES of a lock are
- to make them fair
- to make a thread responsive to interruption while waiting on a Lock object.
- to try to acquire the lock, but return immediately or after a timeout if the lock can’t be acquired
- to acquire and release locks in different scopes, and in different orders

> Some important interfaces and classes in Java Concurrency Lock API are
1 Condition: it objs similar to Obj wait-notify model 
- A Condition object is always created by Lock object. 
- it methods are await() ~ wait() ,signal(), signalAll() ~ notify(), notifyAll().

2 ReadWriteLock - It contains pair of associated locks, one for read-only operations and another one for writing. 
- The read lock may be held simultaneously by multiple reader threads as long as there are no writer threads. 
- The write lock is exclusive.

3 ReentrantLock - This class implements the Lock interface in similar way as synchronized keyword. 
- it contains some utility methods to get the thread holding the lock, threads waiting to acquire the lock etc.
- synchronized block are reentrant in nature i.e if a thread has lock on the monitor object and if another synchronized block requires to have the lock on the same monitor object then thread can enter that code block
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is differences between Lock and synchronization ?
=======================================
########### ReadWriteLock[i] ###########

>  request for read lock by multiple threads can be acquired simultaneously if there is no write lock request
- If a thread acquires write lock on a resource, then no other read or writes lock by any thread 
=======================================
########### ReentrantLock[c] ###########
## What is ReentrantLock ?

> it is concrete impl of Lock[i]. 
> Since Java5
> it is mutual exclusive lock similar to synchr 
> it include additional features of FAIRNESS of long waiting thread.
> Lock is acquired by lock() tht can be held by Thread until it call unlock() 

> SYNCHRONIZED BLOCK ARE REENTRANT IN NATURE i.e. 
- if a thread has lock on the monitor object and if another synchronized block requires to have the lock on the same monitor object then 
- thread can enter that code block

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--
## What is difference between ReentrantLock and Synchronized keyword ?
> The main difference is ability to trying for lock interruptibly, and with timeout. 
- Thread doesn’t need to block infinitely, which was the case with synchronized

> Another significant difference is FAIRNESS
> synchronized keyword doesn't support fairness. Any thread can acquire lock once released, no preference can be specified, 
- we can make ReentrantLock fair by specifying fairness property, while creating instance of ReentrantLock. 
- Fairness property provides lock to longest waiting thread, in case of contention.

> ReentrantLock provides tryLock() which acquires lock only if its available or not held by any other thread
- This reduce blocking of thread waiting for lock

> ReentrantLock introduce the ability to interrupt Thread while waiting for Lock.
- it provide lockInterruptibly(), used to interrupt thread when it is waiting for lock.
- tryLock() with timeout can also be use
= But with synchr, thread cab be blocked waiting for lock for indefinite time.

> it provide methods to get List of all thread waiting for lock.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--
## What are the DISADVANTAGE OF REENTRANTLOCK?
> wrapping method body inside try-finally block make code unreadable and hide business logic.

> Aquiring and releasing lock is in hand of prgmr, it need to be use efficiently otherwise may cause bug.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--
> Synchronized use intrinsic locks or monitor of obj
LIMITATIONS of intrinsic locking mechanism:

1 It is not possible to interrupt a thread waiting to acquire a lock (lock Interruptibly).
2 It is not possible to attempt to acquire a lock without being willing to wait for it forever (try lock).
3 Cannot implement non-block-structured locking disciplines, as intrinsic locks must be released in the same block in which they are acquired.
=======================================
########### ReentrantReadWriteLock[c] ###########

> ReentrantReadWriteLock is the implementation of ReadWriteLock[i] and ReadWriteLock extends Lock[i]
> Similar to ReentrantLock, it also allows a thread to acquire the read lock or write lock multiple times recursively, thus the word “Reentrant”.

> It maintains two separate locks, one for reading and one for writing:
- Lock readLock = rwLock.readLock();
- Lock writeLock = rwLock.writeLock();

> ReentrantReadWriteLock can behave as fair and non-fair mode both. 
- The default behavior is non-fair. 
- The performance of non-fair lock is better though it is possible that a READER OR WRITER LOCK CAN BE POSTPONED MANY TIMES which are continuously trying to lock.
- In case of FAIR LOCK the locking request is fulfilled in the order that either the longest waiting single writer lock or the group of read locks request, whosoever has longest waiting time will acquire lock on the shared resource. 

> Then you can use the read lock to safeguard a code block that performs read operation like this:
readLock.lock(); 
try {
    // reading data
} finally {
    readLock.unlock();
}

> And use the write lock to safeguard a code block that performs update operation like this:
writeLock.lock();
try {
    // update data
} finally { 
    writeLock.unlock();
}

> A ReadWriteLock implementation guarantees the following behaviors:
1. Multiple threads can read the data at the same time, as long as there’s no thread is updating the data.
2. Only one thread can update the data at a time, causing other threads (both readers and writers) block until the write lock is released.
3. If a thread attempts to update the data while other threads are reading, the write thread also blocks until the read lock is released.

- It can be used to add concurrency features to a data structure, but it doesn’t guarantee the performance because 
- it depends on various factors: how the data structure is designed, the contention of reader and writer threads at real time, CPU architecture (single core  or multicores), etc.
=======================================
##How to find a deadlock has occurred in Java? How to detect a Deadlock in Java?

> Earlier versions of Java had no mechanism to handle/detect deadlock. 
> Since JDK 1.5 there are some powerful methods added in the java.lang.management package to diagnose and detect deadlocks. 
> The java.lang.management.ThreadMXBean interface is management interface for the thread system of the Java virtual machine. 
- It has two methods which can leveraged to detect deadlock in a Java application.

1. findMonitorDeadlockedThreads() 
- This method can be used to detect cycles of threads that are in deadlock waiting to acquire object monitors. 
- It returns an array of thread IDs that are deadlocked waiting on monitor.

2. findDeadlockedThreads() - It returns an array of thread IDs that are deadlocked waiting on monitor or ownable synchronizers.

 import java.lang.management.ThreadMXBean;        
      {...
        ThreadMXBean bean = ManagementFactory.getThreadMXBean();
        System.out.println("Bean: " + bean);
            ...
        System.out.println("Monitor deadlocked threads: " + bean.findMonitorDeadlockedThreads());
       long[] ids = bean.getAllThreadIds();
	   
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##What is JAVA MEMORY MODEL?
> it describes the communication between the memory of the threads and the main memory of the application.
> It defines the rules how changes in the memory done by threads are propagated to other threads

> It guarentee that the changes made by one thread should be visible to other. 

Happens-before relationship guarantees :

PROGRAM ORDER RULE : Each action in a thread happens-before every action in that thread that comes later in the program order, this is known as .

MONITOR LOCK RULE : An unlock on a monitor lock happens-before every subsequent lock on that same monitor lock.

A write to a volatile field happens-before every subsequent read of that same field, known as Volatile variable rule.
A call to Thread.start on a thread happens-before any other thread detects that thread has terminated, either by successfully return from Thread.join() or by Thread.isAlive() returning false, also known as Thread start rule.
A thread calling interrupt on another thread happens-before the interrupted thread detects the interrupt( either by having InterruptedException thrown, or invoking isInterrupted or interrupted), popularly known as Thread Interruption rule.
The end of a constructor for an object happens-before the start of the finalizer for that object, known as Finalizer rule.

If A happens-before B, and B happens-before C, then A happens-before C, which means happens-before guarantees Transitivity.

http://www.xyzws.com/Javafaq/can-transient-variables-be-declared-as-final-or-static/0 
================================

##What is Scheduler?
> it is process that implemented with scheduler algo. used to manage process and thread to access critical resource.
> it provide load balancing bet avail process and thread