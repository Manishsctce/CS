########### Java SE 8(jdk1.8) #########
> Released on 18 March 2014
> code name culture is dropped

It has added below features:-
1. LAMBDA EXPRESSION
2. DEFAULT METHODS (formerly called  or defender methods)
> define methods in Interface; DEFAULT METHOD OR DEFENDER METHOD [02b]

3. FUNCTIONAL INTERFACE : more details in 02c_Interfaces_-_Serialization_Externalizable_Clonable.txt
4. METHOD REFERENCE
5. Optional Class
6. Stream update : 04g_java.util_Utility_classes.txt
=====================================
## What is FUNCTIONAL PROGRAMMING?

> its a style of pgmg where we FOCUS ON TRANSFORMING DATA THROUGH THE USE OF SMALL EXPRESSIONS THAT IDEALLY DON’T CONTAIN SIDE EFFECTS.

EXAMPLE = 
f(x) = x^2
f(a,b) = a2 +b2 +2ab
f(a,b)= f(a)+f(b)+2ab 

Similarly in pgmg lang, we have use fn that doesn't have any side effect as a building block of another fn.

> In Functional programming, PASS IMMUTABLE DATA WOULD NOT LEAD TO CONCURRENCY ISSUE 
- function should not involve in modifying the scope of it.

> FUNCTIONS SHOULD BE STATELESS IN FUNCTIONAL STYLE PROGRAMMING.  
- That means, they should not using any state of the objects data or maintain some state outside its scope for its execution.
- By maintaining state, it could possibly lead to concurrency issue 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Where should we use Functional programming?

> When there is continous changes in data require like a stream of data to modify.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is diff bet Imperative style / Declarative style of prgm?

IMPERATIVE 
- It is where we say 'what to do?' and 'how to do?'

DECLARATIVE / FUNCTIONAL 
- In this style of programming, we say 'what to do?' and we don't need to say 'how to do?'
=======================================
########## LAMBDA EXPRESSION ##########
> Since Java8

## What is Lambda expression?
## Explain the syntax and characteristics of a Lambda Expression?

> It is an ANONYMOUS FUNCTION THAT CAN BE REFERENCED AND PASSED AROUND AS AN OBJECT & EXECUTED LaTER
- It comprises of a set of parameters, a lambda operator (->) and a function body.

> it represented as objects, and so they must be bound to a particular object type known as a Functional Interface. This is called the target type.

#### PARAMETERS ####
> It can receive zero, one or more parameters.

> The type of parameters can be explicitly declared OR 
- it can be inferred from the context.

> Parameters are enclosed in parentheses and separated by commas.
- Empty parentheses are used to represent an empty set of parameters.
- When there is a single parameter, if its type is inferred, it is not mandatory to use parentheses.

#### BODY ####
> it can be zero, one or more statements.

> For 1 statement, curly brackets are not mandatory and 
- return type of anonymous function is same as that of body expression.

> For >1 statement, it must be enclosed in curly brackets (a code block) and 
- return type of anonymous func is same as type of value returned within code block, OR void if nothing is returned.

EXAMPLE - 
n -> n % 2 != 0;
- Given a number n returns a boolean indicating if it is odd.

(char c) -> c == 'y';
Given a character c returns a boolean indicating if it is equal to ‘y’.

(x, y) -> x + y;
- Given two numbers x and y returns another number with their summation.

(int a, int b) -> a * a + b * b;
- Given two integers a and b returns another integer with the sum of their squares.

() -> 42
- Given no parameters returns the integer 42.

() -> { return 3.14 };
Given no parameters returns the double 3.14.

(String s) -> { System.out.println(s); };
Given a string s prints the string to the main output and returns void.

() -> { System.out.println("Hello World!"); };
Give no parameters prints Hello World! to the main output and returns void.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
> It is replacement for anonymous classes as method arguments
> One issue with anonymous classes is that if the implementation of your anonymous class is very simple, such as an interface that contains only one method, 
- then the syntax of anonymous classes may seem unwieldy and unclear. 
- In these cases, We're usually trying to pass functionality as an argument to another method.
- Lambda expressions enable us to do this, to treat functionality as method argument, or code as data.


> lambda expressions are Java's first step into functional programming.
- Functional programming is very often used to implement event listeners
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Why use Lambda expression?

> It is used to define inline implementation of Functional interface.
> It  eliminates the need of anonymous class
> Less coding.

=======================================
########## METHOD REFERENCE ###########

## What is a method reference?

> It is a compact, easy-to-read handle for a method that already has a name. 
- It is more compact than annonymous class and lambda exp. 

> it can be used for referencing a method of Functional Interface without invoking it. 
- It is USED FOR TREATING METHODS AS LAMBDA EXPRESSIONS.
- It is compact and easy form of lambda expression

> it can be identified by a double colon separating a class or object name and the name of the method
(o) -> o.toString(); 
Object::toString();

numbers.forEach(value -> System.out.println(value));
numbers.forEach(System.out::println);

## FOUR KINDS OF METHOD REFERENCES ##

1. Reference to a static method	
Ex - ContainingClass::staticMethodName

2. Reference to an instance method of a particular object	
Ex - containingObject::instanceMethodName

3. Reference to an instance method of an arbitrary object of a particular type	
Ex - ContainingType::methodName

4. Reference to a constructor	
Ex - ClassName::new

## When to use method reference?
- When a Lambda expression is invoking already defined method, you can replace it with reference to that method.

## When you can not use Method reference?
- You CAN NOT PASS ARGUMENTS TO THE METHOD REFERENCE.

> In general, we don't have to pass arguments to method references. However, arguments are treated depending on the type of method reference.
- In this case, any arguments (if any) taken by the method are passed automatically behind the curtains.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
EXAMPLE :

interface IsReferable {
   public void referenceDemo();
}

class ReferenceDemo {

  psv commonMethod() {
    syso("This method is already defined.");
  }

  pv implement() {
    //1. ANONYMOUS CLASS.
    IsReferable demoOne = new IsReferable() {
      @Override
      pv referenceDemo() {
        ReferenceDemo.commonMethod();
      }
    };
    demoOne.referenceDemo();

    //2. LAMBDA IMPLEMENTAION.
    IsReferable demo = () -> ReferenceDemo.commonMethod();
    demo.referenceDemo();

    //3. METHOD REFERENCE.
    IsReferable demoTwo = ReferenceDemo::commonMethod;
    demoTwo.referenceDemo();
  }
}
=======================================
############ JAVA 8 STREAM ############

> Suppose we want to iterate over a list of integers and find out sum of all the integers greater than 10.

// Prior to Java 8
private static int sumIterator(List<Integer> list) {
	Iterator<Integer> it = list.iterator();
	int sum = 0;
	while (it.hasNext()) {
		int num = it.next();
		if (num > 10) {
			sum += num;
		}
	}
	return sum;
}

> There are 3 MAJOR PROBLEMS with the above approach:
1. we have provided how the iteration will take place, this is also called external iteration
2. The program is SEQUENTIAL IN NATURE, NO WAY TO MAKE IT PARALLEL easily.
3. There is a LOT OF CODE to do even a simple task.

> To overcome all the above shortcomings, Java 8 Stream API was introduced. 
- We can use Java Stream API to implement internal iteration, that is better because java framework is in control of the iteration.

> Internal iteration provides several features such as sequential and parallel execution, filtering based on the given criteria, mapping etc.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is Stream?

> A stream is a sequence of objects that supports various methods which can be pipelined to produce the desired result.
> The features of Java stream are –

- A stream is not a data structure instead it takes input from the Collections, Arrays or I/O channels.
- Streams don’t change the original data structure, they only provide the result as per the pipelined methods.
- Each intermediate operation is lazily executed and returns a stream as a result, hence various intermediate operations can be pipelined. Terminal operations mark the end of the stream and return the result.

###### METHODS #######
## INTERMEDIATE METHOD
1. map: it is used to map the items in the collection to other objects according to the Function passed as argument.
List number = Arrays.asList(2,3,4,5);
List square = number.stream().map(x->x*x).collect(Collectors.toList());

2. filter: it is used to select elements as per the Predicate passed as argument.
List names = Arrays.asList("Reflection","Collection","Stream");
List result = names.stream().filter(s->s.startsWith("S")).collect(Collectors.toList());

3. sorted: it is used to sort the stream.
List names = Arrays.asList("Reflection","Collection","Stream");
List result = names.stream().sorted().collect(Collectors.toList());

## TERMINAL OPERATIONS
4. collect: The collect method is used to return the result of the intermediate operations performed on the stream.
List number = Arrays.asList(2,3,4,5,3);
Set square = number.stream().map(x->x*x).collect(Collectors.toSet());

5. forEach: The forEach method is used to iterate through every element of the stream.
List number = Arrays.asList(2,3,4,5);
number.stream().map(x->x*x).forEach(y->System.out.println(y));

6. reduce: The reduce method is used to reduce the elements of a stream to a single value.
The reduce method takes a BinaryOperator as a parameter.
List number = Arrays.asList(2,3,4,5);
int even = number.stream().filter(x->x%2==0).reduce(0,(ans,i)-> ans+i);

## 
7. of(T… values) returns a sequential ordered stream whose elements are the specified values. 
- Stream.of() method simply calls the Arrays.stream() method for non-primitive types

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is the difference between intermediate and terminal operation on Stream? 

> The INTERMEDIATE STREAM OPERATION returns another Stream 
- Which means we can further call other methods of Stream class to compose a pipeline.

EXAMPLE - after calling map() or flatMap() we can still call filter() on Stream.

> TERMINAL OPERATION produces a result other than Stream e.g. a value or a Collection.

- Once a terminal method like forEach() or collect() is called we cannot call any other method of Stream or reuse the Stream.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## is there any difference bet Stream.forEach() and Collection.forEach()?

> With Stream.forEach, the order is undefined
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
### Difference between map() and flatMap() in Java8 Stream?

# map() 
- it applies a fn on each ele of stream and stores the value returned by the fn into a new Stream. 
- This way one stream is transformed into another 
- e.g. a Stream of String is transformed into a Stream of Integer.

> it is used for transformation only

# flatMap() 
- it can take a Stream of List and return Stream of values combined from all those list.

> it is used for both transformation and flattening.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## How Stream.map() works in Java 8?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Difference between Arrays.stream() and Stream.of()

> Even if Stream.of() is a wrapper over the Arrays.stream()

1. DIFFERENT RETURN TYPES
- For primitives arrays (like int[], long[] etc), Arrays.stream() returns typeStream like IntStream and Stream.of() returns Stream

2. Stream.of() needs flattening whereas Arrays.stream() does not
EXAMPLE:
  // to convert int array into Stream 
  IntStream intStream = Arrays.stream(arr); 
  
  // to convert int array into Stream 
  Stream<int[]> stream = Stream.of(arr); 
  
  // flattenning Stream<int[]> into IntStream using flatMapToInt() 
  IntStream intStreamNew = stream.flatMapToInt(Arrays::stream);

3. Stream.of() is generic whereas Arrays.stream is not:
> Arrays.stream() method only works for primitive arrays of int[], long[], and double[] type, and returns IntStream, LongStream and DoubleStream respectively. 
- For other primitive types, Arrays.stream() won’t work.

> Stream.of() returns a generic Stream of type T (Stream). Hence, it can be used with any type.  
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What does peek() does? When should you use it?
 
> The peek() of Stream class allows you to see through a Stream pipeline. 
- we can peek through each step and print meaningful messages on the console. 
- It's generally used for debugging issues related to lambda expression and Stream processing.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What do you mean by saying Stream is lazy?

> It mean methods in Stream[c] is lazy, it will not work by just including them on Stream pipeline.

- It will only work when we call a terminal method on the Stream and 
- finish as soon as they find the data they are looking for rather than scanning through the whole set of data.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is the difference between a normal and functional interface in Java? 

> The normal interface in Java can contain any number of the abstract method while the functional interface can only contain just one abstract method.

You might be thinking why they are called functional interface? Once you know the answer, it might be a little easier for you to remember the concept.

Well, they are called functional interface because they wrap a function as an interface. The function is represented by the single abstract method on the interface.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is difference between findFirst() and findAny() method? 

> findFirst()  will return the first element meeting the criterion i.e. Predicate 
- findAny() will return any element meeting the criterion, very useful while working with a parallel stream. 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Can you convert an array to Stream? How? (answer)

> Yes, we can convert an array to Stream in Java. 
> The Stream class provides a factory method to create a Stream from an array like Stream.of(T ...) which accepts a variable argument, that means you can also pass an array to it as shown in the following example:

EXAMPLE:
String[] languages = {"Java", "Python", "JavaScript"};
Stream numbers = Stream.of(languages);
numbers.forEach(System.out::println);

Output:
Java
Python
JavaScript
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is the parallel Stream? How can you get a parallel stream from a List?

> A parallel stream can parallel execute stream processing task. For example, if you have a parallel stream of 1 million orders and you are looking for orders worth more than 1 million then you can use a filter to do that.

Unlike sequential Stream, the parallel stream can launch multiple threads to search for those orders on the different part of Stream and then combine the result.

############ JAVA 8 STREAM ############
> Suppose we want to iterate over a list of integers and find out sum of all the integers greater than 10.

> Prior to Java 8, the approach to do it would be:

private static int sumIterator(List<Integer> list) {
	Iterator<Integer> it = list.iterator();
	int sum = 0;
	while (it.hasNext()) {
		int num = it.next();
		if (num > 10) {
			sum += num;
		}
	}
	return sum;
}
There are three major problems with the above approach:

1. We just want to know the sum of integers but we would also have to provide how the iteration will take place, this is also called external iteration because client program is handling the algorithm to iterate over the list.
2. The program is sequential in nature, there is no way we can do this in parallel easily.
3. There is a lot of code to do even a simple task.

> To overcome all the above shortcomings, Java 8 Stream API was introduced. 
- We can use Java Stream API to implement internal iteration, that is better because java framework is in control of the iteration.

> Internal iteration provides several features such as sequential and parallel execution, filtering based on the given criteria, mapping etc.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Stream provides following features:
> Stream does not store elements. 
- It simply conveys elements from a source such as a data structure, an array, or an I/O channel, through a pipeline of computational operations.

> Stream is functional in nature. 
- Operations performed on a stream does not modify it's source. 
- For example, filtering a Stream obtained from a collection produces a new Stream without the filtered elements, rather than removing elements from the source collection.

> Stream is lazy and evaluates code only when required.

> The elements of a stream are only visited once during the life of a stream. 
- Like an Iterator, a new stream must be generated to revisit the same elements of the source.

##EMPTY STREAM
Stream<String> streamEmpty = Stream.empty();

##STREAM OF COLLECTION
Collection<String> collection = Arrays.asList("a", "b", "c");
Stream<String> streamOfCollection = collection.stream();

##STREAM OF ARRAY
Stream<String> streamOfArray = Stream.of("a", "b", "c");

String[] arr = new String[]{"a", "b", "c"};
Stream<String> streamOfArrayFull = Arrays.stream(arr);

##Stream of any type
Stream<String> strStream = Stream.of("a", "b", "c");
strStream.foreach(System.out::print());

##Stream iterate
Stream<Integer> streamIterated = Stream.iterate(40, n -> n + 2).limit(20);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##Stream of Primitives
> As Stream<T> is a generic interface and there is no way to use primitives as a type parameter with generics, 
- three new special interfaces were created: IntStream, LongStream, DoubleStream.

IntStream intStream = IntStream.range(1, 3);
LongStream longStream = LongStream.rangeClosed(1, 3);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#### PARALLEL STREAMS ####
=======================================
######### FUNCTIONAL INTERFACE ########
> It is added in Java8

##Describe some of the functional interfaces in the standard library.?

> There are a lot of FI in the java.util.function package, some are:

1. FUNCTION 
– it takes one argument and returns a result

2. CONSUMER 
– it takes one argument and returns no result (represents a side effect)

3. SUPPLIER 
> it takes not argument and returns a result
- It's similar to the factory method or new() which return an object.

4. PREDICATE 
– it takes one argument and returns a boolean

5. BIFUNCTION 
– it takes two arguments and returns a result

6. BINARYOPERATOR 
– it is similar to a BiFunction, taking two arguments and returning a result. 
- The two arguments and the result are all of the same types

7. UNARYOPERATOR 
– it is similar to a Function, taking two arguments and returning a result. 
- The argument and the result are all of the same types
=====================================
########### Function[i] #############

##### 1. Function and BiFunction ###### 
> Function represents a function that takes one type of argument and returns another type of argument. 
- Function<T, R> is the generic form where T is the type of the input to the function and R is the type of the result of the function.

> For handling primitive types, there are specific Function interfaces 
– ToIntFunction, ToLongFunction, ToDoubleFunction, ToIntBiFunction, ToLongBiFunction, ToDoubleBiFunction, LongToIntFunction, LongToDoubleFunction, IntToLongFunction, IntToDoubleFunction etc.

##Stream methods where Function or it’s primitive specialization is used are:

1. <R> Stream<R> map(Function<? super T, ? extends R> mapper)
2. IntStream mapToInt(ToIntFunction<? super T> mapper) 
– similarly for long and double returning primitive specific stream.

3. IntStream flatMapToInt(Function<? super T, ? extends IntStream> mapper) 
– similarly for long and double

4. <A> A[] toArray(IntFunction<A[]> generator)

5. <U> U reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##What is java.util.function.Function<T,R>?

> it is an in-built functional interface introduced in Java 8
> It is USED FOR MAPPING SCENARIOS i.e when an object of a type is taken as input and it is converted(or mapped) to another type.

> Function Descriptor is T -> R. 
- This means an object of type T is input to the lambda and an object of type R is obtained as return value

@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
 
	default <V> Function<V, R> compose(Function<? super V, ? extends T> before) {
        Objects.requireNonNull(before);
        return (V v) -> apply(before.apply(v));
    }
    default <V> Function<T, V> andThen(Function<? super R, ? extends V> after) {
        Objects.requireNonNull(after);
        return (T t) -> after.apply(apply(t));
    }
    static <T> Function<T, T> identity() {
        return t -> t;
    }
}
andThen() 
- which combines the function on which it is applied(current function) with another function, named after


=======================================
#### 2. Predicate and BiPredicate #####
> It represents a predicate against which elements of the stream are tested. 
- This is used to filter elements from the java stream. 
- Just like Function, there are primitive specific interfaces for int, long and double.

> It is a FI with test(Object) as abstract method
- return boolean value and take only 1 arg
SYNTAX 
	Predicate<Type> p = condition
EXAMPLE
    Predicate<Person> person = p -> p.getAge()>30; 
	
## Stream methods 
Stream<T> filter(Predicate<? super T> predicate)
boolean anyMatch(Predicate<? super T> predicate)
boolean allMatch(Predicate<? super T> predicate)
boolean noneMatch(Predicate<? super T> predicate)
=======================================
#### 3. Consumer[i] and BiConsumer ####

> It represents an operation that accepts a single input argument and returns no result. 
- It can be used to perform some action on all the elements of the java stream.
> It contains an abstract accept() and a default andThen()

## Stream methods
Stream<T> peek(Consumer<? super T> action)
void forEach(Consumer<? super T> action)
void forEachOrdered(Consumer<? super T> action)
=======================================
############# 4. Supplier #############
> Supplier represent an operation through which we can generate new values in the stream. 

## Stream methods
public static<T> Stream<T> generate(Supplier<T> s)
<R> R collect(Supplier<R> supplier,BiConsumer<R, ? super T> accumulator,BiConsumer<R, R> combiner)

=====================================
########### SUPPLIER[i] #############
\> It is a FI with get(). 
- get() doesn't take any input and return Object.

> Lambda is represented as 
  () -> T  here T is the type of the supplier
=====================================
########### PREDICATE[i] ############  

=====================================
######### BEST USAGES OF JAVA 8 #####

> Avoid Overloading Methods with Functional Interfaces as Parameters
EXAMPLE: 

public interface Adder {
    String add(Function<String, String> f);
    void add(Consumer<Integer> f);
}
 
public class AdderImpl implements Adder {
 
    @Override
    public  String add(Function<String, String> f) {
        return f.apply("Something ");
    }
 
    @Override
    public void add(Consumer<Integer> f) {}
}

WHILE USING IT String r = adderImpl.add(a -> a + " from lambda"); // IT WILL THROW ERROR add is ambiguous both method

> to solve this problem, we can use methods with different name OR
- to perform casting manually. This is not preferred.
String r = Adder.add((Function) a -> a + " from lambda");

=====================================
############# OPTIONAL ##############
- It is introduced in Java 8 and is similar to what Optional is in Guava.

## What is Optional[c]?

> Optional is a container object which is used to contain not-null objects. 
- It is used to represent null with absent value. 
- This class has various utility methods to facilitate code to handle values as ‘available’ or ‘not available’ instead of checking null values. 


> It is a single-value container that either contains a value or doesn’t.

Rule 1 : Never, ever, use null for an Optional variable or return value. 
Rule 2 : Never use Optional.get() unless you can prove that the Optional is present.
- prefer alternative to Optional.isPresent() and Optional.get()


######## METHOD ########

## 3 METHODS TO CREATE OPTIONAL INSTANCE 
1. static <T> Optional<T> empty()
- Returns an empty Optional instance.

2. static <T> Optional<T> of(T value)
- Returns an Optional with default non-null value.
- If we pass null in of(), then a NullPointerException is thrown immediately.

3. static <T> Optional<T> ofNullable(T value)
- Returns an Optional describing the specified value, if non-null, otherwise returns an empty Optional.

## METHODS TO DO STH If Optional value is present 
4. boolean isPresent()
- Returns true if there is a value present, otherwise false.

5. void ifPresent(Consumer<? super T> consumer)
- If a value is present, it invokes the specified consumer with the value, otherwise does nothing.

6. T get()
- If a value is present in this Optional, returns the value, otherwise throws NoSuchElementException.

## METHODS TO APPLY SOME LOGIC ON Optional
7. Optional<T> filter(Predicate<? super <T> predicate)
- If a value is present and the value matches a given predicate, it returns an Optional describing the value, otherwise returns an empty Optional.

8. <U> Optional<U> flatMap(Function<? super T,Optional<U>> mapper)
- If a value is present, it applies the provided Optional-bearing mapping function to it, returns that result, otherwise returns an empty Optional.

9. <U>Optional<U> map(Function<? super T,? extends U> mapper)
- If a value is present, applies the provided mapping function to it, and if the result is non-null, returns an Optional describing the result.

## METHODS FOR DEFAULT/ABSENT VALUES AND ITS ACTIONS
10. T orElse(T other)
- Returns the value if present, otherwise returns other.

11. T orElseGet(Supplier<? extends T> other)
- Returns the value if present, otherwise invokes other and returns the result of that invocation.

12. <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier)
- Returns the contained value, if present, otherwise throws an exception to be created by the provided supplier.

## OTHER
13. int hashCode()
- Returns the hash code value of the present value, if any, or 0 (zero) if no value is present.

14. boolean equals(Object obj)
- Indicates whether some other object is "equal to" this Optional.

15. String toString()
- Returns a non-empty string representation of this Optional suitable for debugging.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## How Optional works in JVM?

> Inside Optional, value holds is defined as:

//If non-null, the value; if null, indicates no value is present
private final T value;

> empty Optional is declared as 
private static final Optional<?> EMPTY = new Optional<>();

> default no-args constructor is private, so we can’t create an instance of Optional except 3 way 

> When we create an Optional then below call happen at end and assign the passed value to ‘value’ attribute.
this.value = Objects.requireNonNull(value);

> When we try to get a value from an Optional

public T get() {
    if (value == null) {
        throw new NoSuchElementException("No value present");
    }
    return value;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Where does Java Optional fits?

If we observe above real-time Retail Domain use-case, we should know that Java Optional construct is useful at the following places.

1. Method Parameter
EXAMPLE: 
public void setResolution(Optional<ScreenResolution> resolution) {
	this.resolution = resolution;
}

2 Method Return Type
EXAMPLE: 
public Optional<ScreenResolution> getResolution() {
	return resolution;
}

3. Constructor Parameter
EXAMPLE: 
public DisplayFeatures(String size, Optional<ScreenResolution> resolution){
	this.size = size;
	this.resolution = resolution;
}

4. Variable Declaration
EXAMPLE: 
private Optional<ScreenResolution> resolution;

5. Class Level

EXAMPLE: 
public class B
public class A<T extends Optional<B>> { }

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~