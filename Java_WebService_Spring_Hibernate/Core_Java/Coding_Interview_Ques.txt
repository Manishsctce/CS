
## You are given an array of positive integers. Convert it to a sorted array with minimum cost (minimum number of operations). Only valid operation are
1) Decrement -> cost = 1
2) Delete an element completely from the array -> cost = value of element
For example:
4,3,5,6, -> cost 1 //cost is 1 to make 4->3
10,3,11,12 -> cost 3 // cost 3 to remove 3

http://www.geeksforgeeks.org/forums/topic/amazon-interview-question-for-software-engineerdeveloper-about-algorithms-arrays-29/

-------------------
##
class Test {
  public static void main(String[] args) {
    for(int i = 0; 1; i++) {
      System.out.println("Hello");
      break;
    }
  }
}
Output: Compiler Error
- There is an error in condition check expression of for loop. 
- Java differs from C++(or C) here. C++ considers all non-zero values as true and 0 as false. 
- Following is the corrected program.

// filename Test.java
class Test {
    public static void main(String[] args) {
        for(int i = 0; true; i++) {
            System.out.println("Hello");
            break;
        }
    }
}
// Output: Hello
=======================================
##
class Test {
  public static void main(String args[]) {
    System.out.println(fun());
  }
  static int fun() {
    static int x= 0;
    return ++x;
  }
}
Output: Compiler Error
- Unlike C++, static local variables are not allowed in Java. 

Following is the corrected program:
class Test {
   private static int x;
   public static void main(String args[]) {
       System.out.println(fun());
   }
   static int fun() {
       return ++x;
   }
}
// Output: 1
=======================================
##DS
##Check whether a BT is a full BT?
##Binomial tree
http://www.geeksforgeeks.org/binomial-heap-2/

##Oracle
Giving a number T, print out all possible ways to get to T. 
For example 
T= 5 
1 + 1 + 1 +1 +1 
2 + 1 + 1 + 1 
3 + 1 +1 
2 + 2 + 1 
4 + 1 
3 + 3 

Note that, 3 + 2 is equal than 2 + 3, so you don´t have to print both cases. What is the time complexity?
Brute force is not allow

##oracle DS
Given a binary search tree, design an algorithm which creates a linked list of all the nodes at each depth (i.e., if you have a tree with depth D, you’ll have D linked lists).
---------------
##
Write a program to swap two numbers with out using third variable?

a = a+b;
b = a-b;
a = a-b;

-----------------------------
write my own implementation to remove duplicated values in an array. Here is what I have created. But after tests with 1,000,000 elements it took very long time to finish. Is there something that I can do to improve my algorithm or any bugs to remove ?

I need to write my own implementation - not to use Set, HashSet etc. Or any other tools such as iterators. Simply an array to remove duplicates.


http://javarevisited.blogspot.in/2011/04/top-20-core-java-interview-questions.html