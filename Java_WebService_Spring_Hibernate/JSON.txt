## JavaScript Object Notation (JSON) ##
> It is a syntax for storing and exchanging data.

######### JSON SYNTAX RULE ##########
> Data is in name/value pairs
> Data is separated by commas
> Curly braces hold objects
> Square brackets hold arrays

> name/value pair consists of a field name (in double quotes), followed by a colon, followed by a value

=====================================
##### Advantage of JSON over XML ####
> JSON can be parse easily.
- it is easy to read and write and less time consuming.

> It is lightweight i.e shorter in length

=====================================
############# DATA TYPES ############
> In JSON, values must be one of the following data types:
- string Ex - 
- number Ex - { "age":30 }
- Object (JSON object) Ex - { "employee":{ "name":"John", "age":30, "city":"New York" }  }
- array Ex - { "employees":[ "John", "Anna", "Peter" ] }
- boolean Ex -  { "sale":true }
- null Ex - { "middlename":null }

=====================================
###### Accessing Object Values ######

> access the object values by using dot (.) 
> access the object values by using bracket ([]) 

Ex - myObj = { "name":"John", "age":30, "car":null };
x = myObj.name;
x = myObj["name"];
=====================================

> Jackson 2 – 

-------------------------------------
## How to Convert Java Object to JSON?

EXAMPLE 
ObjectMapper mapper = new ObjectMapper();
Staff obj = new Staff();

//Object to JSON in file
mapper.writeValue(new File("c:\\file.json"), obj);

//Object to JSON in String
String jsonInString = mapper.writeValueAsString(obj);

-------------------------------------
## How to convert JSON string to Map using Jackson API?

String jsonStr = "{\"name\":\"Nataraj\", \"job\":\"Programmer\"}";
Map<String,String> resultMap = new HashMap<String,String>();
ObjectMapper mapperObj = new ObjectMapper();
 
System.out.println("Input Json: "+jsonStr);
resultMap = mapperObj.readValue(jsonStr, 
        new TypeReference<HashMap<String,String>>(){});


=====================================
######## JSON ANNOTATION ############
> "org.codehaus.jackson.annotate" package 

@JsonPropertyOrder({ "emp_id", "emp_name", "emp_designation", "department", "salary" })		
- Similar to JXAB @XmlRootElement(propOrder={'f1','f2'..})

@JsonProperty("emp_id")
private int empId;

@JsonIgnore
private String department;

@JsonIgnore : marks a field in a POJO to be ignored by Jackson during serialization and deserialization.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## How to Ignore Unknown Properties While Parsing JSON in Java?

> when Java class doesn't have all the field corresponding to all JSON properties then jackson 
- will throw UnrecognizedPropertyException 

1. at the class level use @JsonIgnoreProperties(ignoreUnknown = true) 
- import com.fasterxml.jackson.annotation.JsonIgnoreProperties.

2. at the ObjectMapper level using configure() method.
- Ignoring Unknown Property in JSON Globally using Jackson
- while parsing json, configure ObjectMapper not to fail when it encounters an unknown property as 

ObjectMapper objectMapper = new ObjectMapper();
objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
=======================================
####### Bean Validation #########

> Bean Validation works by defining constraints to the fields of a class by annotating them with certain annotations.
- pass an object of that class into a Validator which checks if the constraints are satisfied.
 
EXAMPLE:

class Input {

  @Min(1)
  @Max(10)
  private int numberBetweenOneAndTen;

  @Pattern(regexp = "^[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}$")
  private String ipAddress;
  
  // ...
} 

import javax.validation.Valid
@RestController
class ValidateRequestBodyController {

  @PostMapping("/validateBody")
  ResponseEntity<String> validateBody(@Valid @RequestBody Input input) {
    return ResponseEntity.ok("valid");
  }
}

> By using @Valid, we’re telling Spring to pass the object to a Validator before doing anything else.
- @RequestBody to mark that it should be read from the request body 
- If the validation fails, it will trigger a MethodArgumentNotValidException. By default, Spring will translate this exception to a HTTP status 400 (Bad Request).
- By default, Spring Data uses Hibernate Validator underneath, which supports Bean Validation out of the box.

> @Validated at the class level controller, use to tell spring to evaluate the constraint annotations on method parameters
- only @valid at parameter level will not work. 


> to disable Bean Validation, use this property:-
spring.jpa.properties.javax.persistence.validation.mode = none
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## 
