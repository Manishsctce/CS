######## Spring MVC #######

## What is Spring MVC framework?

> Spring web MVC framework provides model-view-controller architecture.
- It is USED TO DEVELOP FLEXIBLE AND LOOSELY COUPLED WEB APPLICATIONS. 

> MVC pattern separate the different aspects of the application (input logic, business logic, and UI logic), and provide loose coupling between model, view and controller. 

##ADVANTAGES OVER OTHER MVC frameworks
> Clear separation of roles – controller, validator, command object, form object, model object, DispatcherServlet, handler mapping, view resolver, etc. 
-Each role can be fulfilled by a specialized object.

> Reusable business code 
> Customizable binding and validation
> Customizable handler mapping and view resolution
=======================================
######### DispatcherServlet ###########

## What is DispatcherServlet?
## What is the front controller class of Spring MVC?

> It is request-driven designed 
> It is a central Servlet that work as the FRONT CONTROLLER AND HANDLES ALL THE HTTP REQUESTS AND RESPONSES.
- It is responsible to manage the flow of the spring MVC App.

> It is RESPONSIBLE FOR INITIALIZE WebApplicationContext (i.e *-servlet.xml) and 
- loads all configuration related to web components like controllers, view resolver, interceptors etc. 
- It will be loaded and initialized by calling init() of DispatcherServlet
- Its work is to forward the request to specific Controller
- Load the map of all URLs and the components responsible to handle the request.
- Prepare the map for the views.

> By default, DispatcherServlet loads its configuration file using <servlet_name>-servlet.xml
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
####### FLOW OF SPRING WEB MVC #######
Request --1-> DispatcherServlet --2-> HandlerMapping
					|-------------3-> Controller
					|<-4---ModelAndView---|
					|-------------5-> ViewResolver
					|-------------6-> View

> all the incoming request is intercepted by the DispatcherServlet					
> DispatcherServlet gets entry of handler mapping from the xml file and 
> DispatcherServlet forwards the request to the controller. 
- The controller returns an object of ModelAndView.
> The DispatcherServlet checks the entry of view resolver in the xml file and
> DispatcherServlet invokes the specified view component.
- if dispatcher doesn't found the page then 404 page not found error.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
> DispatcherServlet initialize below component if available in sequencial manner:-
1. MultipartResolver 
2. LocaleResolver
3. ThemeResolver
4. HandlerMapping
5. HandleAdaptor
6. HandlerExceptionResolver
7. RequestToViewNameTranslator
8. ViewResolver
=======================================
## Request flows inside the DispatcherServlet as follow IN DETAIL:-

1. The request is handled by the doRequest() of the DispatcherServlet. 
- It first sets the following attributes – 
WEB_APPLICATION_CONTEXT_ATTRIBUTE, LOCALE_RESOLVER_ATTRIBUTE, THEME_RESOLVER_ATTRIBUTE, THEME_SOURCE_ATTRIBUTE, INPUT_FLASH_MAP_ATTRIBUTE, OUTPUT_FLASH_MAP_ATTRIBUTE and FLASH_MAP_MANAGER_ATTRIBUTE.

2. IF A MULTIPART RESOLVER IS AVAILABLE then REQUEST IS CONVERTED INTO A MULTIPART REQUEST.

3. The Handler is then obtained for the current request. 
- The code iterates through all handlerMappings and SELECT ONE HANDLERMAPPING THAT SATISFIES THE CURRENT REQUEST. 
- The code may use the URL, session state or other parameters to determine which handler satisfies the current request. 
- The HANDLER RETURNED IS OF TYPE "HandlerChainExecution". It contains the interceptors and the Handler . 
- Note that the HANDLER IS OF TYPE OBJECT and is not bound to any specific interface. 
- It is therefore possible to use handlers from another frameworks to handle requests. 

- Default handlerMapping is "org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping" and "org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping".(more on HandlerMappings)

4. After obtaining the handler, the DispatcherServlet looks for the HandlerAdapter for the current request. 
- Each handler type implements "HandleAdaptor" interface. 
- Each handler type handles the request through the HandlerAdaptor Interface. 
- The default handler adapter for Spring 
"org.springframework.web.HttpRequestHandler" is "org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter" and for 
"org.springframework.web.servlet.mvc.Controller" is "org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"

5. Apply the preHandle() of all interceptors.

6. Invoke the handle method using the HandleAdaptor (handleAdaptor.handle(request,response,handler).
- This returns an object of type ModelAndView.

7. If the returned ModelAndView object does not contain a view name or a view object then the configured RequestToViewNameTranslator will translate the current request into a view name. 
- The default implementation of RequestToViewNameTranslator is org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator. 
- Otherwise a ViewResolver is used to resolve the view from the view name

8. The view is then rendered.

9. Call the trigger AfterCompletion() of the HandlerInterceptors.
=======================================
#### DispatcherServlet.properties #####
> it is the property file which contain mapping of default class used in Spring MVC like  

1. org.springframework.web.servlet.HandlerExceptionResolver	=	org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,
org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,
org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver

2. org.springframework.web.servlet.HandlerMapping	=	org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,
org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping

## Is the DispatcherServlet instantiated via an application context?
> No. ApplicationContext instantiated via DispactcherServlet.
  
=====================================
############## Validator ############

##How to validate form data in Spring Web MVC Framework?

> Spring MVC supports validation by means of a validator object that implements the Validator interface. 
> You need to create a class and implement Validator interface. 
> In this custom validator class, we can use utility methods such as rejectIfEmptyOrWhitespace() and rejectIfEmpty() in the ValidationUtils class to validate the required form fields.

EXAMPLE: 
@Component
public class EmployeeValidator implements Validator
{
    public boolean supports(Class clazz) {
        return EmployeeVO.class.isAssignableFrom(clazz);
    }
  
    public void validate(Object target, Errors errors)
    {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "error.firstName", "First name is required.");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "lastName", "error.lastName", "Last name is required.");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "email", "error.email", "Email is required.");
    }
}
> If any of form fields is empty, these methods will create a field error and bind it to the field. 
- The 2nd arg of ValidationUtils methods is the property name, while 3rd and 4th are the error code and default error message.

> To activate this custom validator as a spring managed bean, you need to do one of following things:

1) Add @Component annotation to EmployeeValidator class and activate annotation scanning on the package containing such declarations.
<context:component-scan base-package="com.howtodoinjava.demo" />

2) Alternatively, you can register the validator class bean directly in context file.
<bean id="employeeValidator" class="com.howtodoinjava.demo.validator.EmployeeValidator" />
=====================================

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What are the differences between Model, ModelMap, and ModelAndView?

##Model: 
- It is an Interface. 
- It defines a holder for model attributes and primarily designed for adding attributes to the model.

EXAMPLE:
@RequestMapping(method = RequestMethod.GET)
public String printHello(Model model) {
  model.addAttribute("message", "Hello World!!");
  return "hello";
}
~~~~~~~~~~~~~~~~~~~~~~~~
## ModelMap: 
- Implementation of Map for use when building model data for use with UI tools.
- Supports chained calls and generation of model attribute names.

EXAMPLE:
@RequestMapping("/helloworld")
public String hello(ModelMap map) {
    String helloWorldMessage = "Hello world!";
    String welcomeMessage = "Welcome!";
    map.addAttribute("helloMessage", helloWorldMessage);
    map.addAttribute("welcomeMessage", welcomeMessage);
    return "hello";
}
~~~~~~~~~~~~~~~~~~~~~~~~
##ModelAndView: 
> ModelAndView is just a container for both a ModelMap and a view object. 
- This class merely holds both to make it possible for a controller to return both model and view in a single return value.

EXAMPLE:
@RequestMapping("/welcome")
public ModelAndView helloWorld() {
  String message = "Hello World!";
  return new ModelAndView("welcome", "message", message);
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PropertyPlaceholderConfigurer



