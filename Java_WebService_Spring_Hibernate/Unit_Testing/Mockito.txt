############## MOCKITO ################

## What is mockito?

> Mockito is a JAVA-based library used for unit testing applications. 
- This open-source library plays an important role in automated unit tests for the purpose of test-driven development or behavior-driven development. 
- It uses a mock interface to add dummy functionality in the unit testing. 
- It also uses Java reflection to create mock objects for an interface to test it.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
> create mock objects using either @Mock annotation or mock() static method.

> MockitoAnnotations.initMocks(this); to initialize objects annotated with @Mock, @Spy, @Captor, or @InjectMocks.


import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.when;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

@RunWith(MockitoJUnitRunner.class)
public class CalcService2Test {
	CalcService calcService;

	@Mock
	AddService addService;

	@BeforeEach
	public void setup() {
		MockitoAnnotations.initMocks(this);
	}

	@Test
	public void testCalc() {
		System.out.println("**--- Test testCalc executed ---**");
		calcService = new CalcService(addService);

		int num1 = 11, num2 = 12, expected = 23;

		when(addService.add(num1, num2)).thenReturn(expected);

		int actual = calcService.calc(num1, num2);
		assertEquals(expected, actual);
	}
}
=======================================
######## MOCKITO ANNOTATIONS ##########

1. 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
####### Mockito Spy ##########
> When you call the method of a spied object, the real method will be called, unless a predefined behavior was defined. 

===============================
###### Void Return Type #######

@Test(expected = IllegalStateException.class)
public void whenConfigVoidRetunMethodToThrowEx_thenExIsThrown() {
    MyDictionary dictMock = mock(MyDictionary.class);
	
    doThrow(IllegalStateException.class)
      .when(dictMock)
      .add(anyString(), anyString());
 
    dictMock.add("word", "meaning");
}
-------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is difference between Assert and Verify in mockito?
Both statements are used to add validations to the test methods in the test suites but they differ in the following.

The Assert command is used to validate critical functionality. If this validation fails, then the execution of that test method is stopped and marked as failed.

In the case of Verify command, the test method continues the execution even after the failure of an assertion statement. The test method will be marked as failed but the execution of remaining statements of the test method is executed normally.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## List some limitations of Mockito?

Some limitations of the mockito are,

> It cannot mock constructors or static methods.
> It requires Java version 6 plus to run.
> It also cannot mock equals(), hashCode() methods.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is use of mock() method in Mockito?

> The Mock() method is used to create and inject the mocked instances. 
- It gives you boilerplate assignments to work with these instances. 
- The other way of creating the instances is using the @mock annotations. 


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is ArgumentCaptor in Mockito?

> ArgumentCaptor is a class that is used to capture the argument values for future assertions. This class is defined in the org.mockito package and can be imported from it.

Some of the methods present in this class are

capture(),
getValue(),
getAllValues(), and ArgumentCaptor <U> forClass.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## List some Mockito Annotations?

Some of the Mockito annotations are,

@Mock - It is used to create and inject mocked instances.
@Spy - It is used to create a real object and spy on the real object.
@Captor - It is used to create an ArgumentCaptor.
@InjectMocks - It is used to create an object of a class and insert its dependencies.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is Hamcrest ?
Hamcrest is a framework used for writing customized assertion matchers in the Java programming language. It allows the match rules to be defined declaratively. This makes the hamcrest valuable in UI validation, data filtering, writing flexible tests, etc. It can also be used with mock objects by using adaptors. Hamcrest can also e used with JUnit and TestNG.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is PowerMock?
PowerMock is a Java framework for unit testing purposes. This framework extends from other mock libraries with more powerful capabilities. It uses custom classloader and bytecode manipulation for mocking the static methods, constructors, final classes, private methods, and more. It normally lets you test the code that is regarded as untestable.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## What is EasyMock?
EasyMock is a framework for creating mock objects as it uses Java reflection to create it for a given interface. It relieves the user of hand-writing mock objects as it uses a dynamic mock object generator.

Some other perks you get with EasyMock are

exception support,
return value support,
refactoring scale,
annotation support and order check support.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Difference between doReturn and thenReturn.

Answer: Mockito provides two different syntaxes for creating stubs like:

doReturn and thenReturn
doNothing (no thenNothing)
doThrow and thenThrow
Both these methods setup stubs and can be used to create/setup stubs and could be used interchangeably at times.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## 